# OSPF, an Event-Driven, asynchrounous, Promise-based, single-page, MVC, Vanilla Javascript framework aimed at developing speed.

## Overview ##
OSPF makes easy to create single pages JavaScript apps, by using components as stand-alone rendered objects, in a MVC-way.
It is pretty fast when it comes to development time, and has no external dependencies.
In addition, it uses Vanilla Javascript only, allowing you to stard developing right away without any additional installation.
You are right, you can start developing directly in your browser just by downloading the .zip file.
It works on desktop, mobile, Cordova, Electron.

## Getting started ##
Clone this repository inside a folder accessible by your webserver:

` git clone https://github.com/omagerio/ospf.git `

Visit the URL of that folder, for example ` http://localhost/myfolder `

Et voil√†. The framework is up and running strong. Easy right?

# Application flow #
The application starts from the `index.js` file you can find in the root of the project. A function named `appInit` will be called when the framework is ready. For example, the default:

```javascript
async function appInit() {
    let main = new TabbedLayoutExample();
    await main.init();
    await root.addChild("main", main);
}
```

This code should be self explanatory.

The `root` var is a special component, globally accessible, and it is the root of your application.
The method "addChild" adds a child to the selected component, and accepts the component being created, and the key of the component.
Read more about components below.
`main` is the only possible child of the root component, and you must start from here.

Ok now the `TabbedLayoutExample` component will be rendered when you start the application.

## Folder structure ##
```text
ospf/					framework folder
	assets/
		css/
			core.css	core css file. Do not edit this file (override in custom.css if needed)
			custom.css	Editable custom css file
		images/
			core/		Core images. Do not edit.
			custom/		Custom images of your app.
		libs/
	components/			Components folder
		core/			Core components. Do not edit this file.
		custom/			Custom components. Create your components here.
	components_core.js	list of core components to load
	components_custom.jslist of custom components to load
	ejs.min.js			EJS library
	ospf.js				Main framework file
index.html				Entry point of your application
index.js				Entry point of your application
README.md				This file

```

## Creating components ##
An example component was made for you to start with.
You can find it inside `ospf/components/custom/HelloWorld`.

- Clone the `HelloWorld` folder with a new name, `myComponent`

Inside this folder, you can find a JS and an HTML file. The js is, surprisingly, the logic of this component. The HTML is the template.

- Rename both files to `myComponent.js` and `myComponent.htm`

- Open the `myComponent.js`

Inside this file you can find a class extending the `Component` class.

- Rename this class to what you want, for example `MyComponent`.

```javascript
class MyComponent extends Component {
	// ...
}
```

You are almost there. Now we have to tell OSPF about your new component, but do not worry, it is faster than you think.

- Open `ospf/components_custom.js` and add `custom/MyComponent` the array.
```javascript
var customComponents = [
	"custom/HelloWorld",
	"custom/MyComponent"
];
```

The HTML file represents the template of the component. Let's see the default tpl:
```html
<div id="<%= c._id %>" class="helloWorld">
    <h1>Hello World!</h1>
    <h3>This is a test component.</h3>
    ...
</div>
```

Here you place the HTML of your panel. Be sure to set the `id` attribute of the tag (can be any tag you want, here is a `div`) to `<%- c._id %>` to allow the framework to recognize the component later on.

> As you can see, this framework uses the extraordinary `ejs` library. Find more here: https://ejs.co/. The library is already included and minimized, no need to install it again.

### Component methods ###
Components have different methods you must know:

- `async init()`: this is a fundamental method of the components. Always call this method after you created your component. You can use this method to pass variables to your component. Always call `await super.init()` before your custom code.
- `renderEvent(string eventName, any parameters, Event javascriptEvent)`: renders an event, for example: `onclick="<%- c.renderEvent("clickHandler") %>"` will call `component.clickHandler(parameters, javascriptEvent)`.
- `async databind()`: loads panel data. You _must_ override this function (and call `super.databind()`) inside your component when you have to load data required from your tpl.
- `async refresh()`: refreshes the component's template. You should never override this method.
- `async update()`: calls `refresh()` and `databind()` sequentially. You should never override this method.
- `render()`: returns the HTML of the component. Use this method inside your template to render children components.
- `async addChild(name, component)`: adds a child component to the current component.
- `async removeChild(name)`: get the child of the current component by name.
- `getChild(name)`: get the child of the current component by name.
- `getChildren()`: get all the children of the component.
- `async fireEvent(string eventName, any parameters)`: fires a global event with parameters.

Inside the template file, you can use `c` to reference your component (for example `c.name`).

### Other methods ###
- `async onFirstRender()`: called when the component is rendered for the first time.
- `async onBeforeRefresh()`: called before the component is refreshed. Please note: render() does not count as a refresh.
- `async onAfterRefresh()`: called after the component is refreshed. Please note: render() does not count as a refresh.
- `async onBeforeReplace()`: called before a component is replaced (with addChild() to a new component for example);
- `async onAfterReplace()`: called before a component is replaced (with addChild() to a new component for example);
- `async onBeforeDestroy()`: called before a component is destroyed (removed with removeChild(), cascades to children);
- `async parseInput()`: parses user input to update components status. It is automatically called when an event is handled. Must call `await super.parseInput()` inside. Use this method when you want to alter the state of the component based on user input.

### Handling events ###
- `async onBeforeEvent(event)`: called when an event is fired, but before other calls.
- `async onEvent(event)`: called when an event is fired. Handle your logic here.
- `async onAfterEvent(event)`: called after an event is fired.

### Compiling ###
> This step is optional.

By default, components are loaded one by one when the application start. You can speed up the startup process by compiling your components in one single file. You can use `tools/compile.js` to perform this operation (requires nodejs and an internet connection):
`node tools/compile.js`.

```javascript
/*
    Set to "false" if you want to test your application without compiling or you don't have nodeJS.
    Set to "true" and run "node tools/compile.js" to generate unified sources. Recommended.
*/
const PRODUCTION_MODE = true;
```

### Testing environment ###
You can start a local webserver by running:
`node tools/server.js`

### That's all folks ###
This is everything you must know if you want to start using OSPF!

Happy coding


> This framework is under heavy development and it may change or break at every update. Please check back frequently.